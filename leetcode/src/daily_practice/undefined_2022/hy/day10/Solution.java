package daily_practice.undefined_2022.hy.day10;

//630.课程表Ⅲ

//这里有 n 门不同的在线课程，按从 1 到 n 编号。给你一个数组 courses ，其中 courses[i] = [durationi, lastDayi] 表示第 i 门课将会 持续 上 durationi 天课，并且必须在不晚于 lastDayi 的时候完成。
//
//你的学期从第 1 天开始。且不能同时修读两门及两门以上的课程。
//
//返回你最多可以修读的课程数目。


//今天这道题我们可以使用贪心来进行求解，同类型的题目还有会议室预订。
//
//假设给定了两门截止时间不同课程，我们应该如何学习呢？
//
//带入到现实中，我们肯定先学习截止时间更近的课程，比如，一门课程在10天后截止，另一门在100天后截止，你肯定会先学习10天后截止的那门课程，对不对？
//
//所以，这种方法能不能经得起推敲呢？我们来证明一下。
//
//假设给定的两门课程分别为 [d1, l1] 和 [d2, l2]，且 l1 <= l2，其中，d 表示 duration，l 表示 lastDay。
//
//如果我们先学习前者，再学习后者，那么需要满足：
//
//\left\{\begin{aligned}d1 <= l1 \\d1 + d2 <= l2\end{aligned}\right.
//
//d1<=l1
//d1+d2<=l2
//
//如果我们先学习后者，再学习前者，那么需要满足：
//
//d2 <= l2
//d2 + d1 <= l1
//
//因为，我们约定了 l1 <= l2，所以，如果先学习后者再学习前者，通过 d2 +d1 <= l1 肯定能够得到 d2 + d2 <= l2，但是，如果我们先学习前者再学习后者，通过 d1 + d2 <= l2 并不一定能够得到 d1 + d2 <= l1，对不对？！
//
//比如说，给定的两门课程为：[1, 3] 和 [2, 5]，这时候，我们无论先学习哪门课程都是可以完成两门课程的。
//
//再比如说，给定的两门课程为：[1, 2] 和 [2, 4]，这时候，如果先学习后者再学习前者，会导致 d2 + d1 > l1，将无法完成前者的学习，因此，我们只能先学习前者再学习后者。
//
//所以，归到一般情况，我们选择截止时间更近的课程优选学习总是优于选择截止时间更远的课程学习。
//
//因此，我们可以将所有课程按截止时间排序，然后依次学习。
//
//但是，这样并不能保证我们前面遍历到的课程学习了，后面的课程就一定能够学习得了。
//
//比如说，给定了三门课程分别为：[1,2] 、[3, 4]、[2, 5]，这时候，当选择到第三门课程的时候，发现 1 + 3 + 2 > 5 的，所以，第三门课程是学习不了的，那么，这时候，在第二门和第三门课程中间做一个选择，你会怎么选择呢？（因为后面可能还有个 [3, 6] 的课程）
//
//因为题目要求了返回 能够学习的最大课程数目，所以，我们应该优先选择学习时长更短的课程，对于上例来说，我们选择 [2, 5] 优于 [3, 4]，因为 [2, 5] 学习时长更短，相当于我们可以有更多的时间学习后续的课程。
//
//因此，我们可以使用优先级队列（大根堆）来维护已经选择了的课程，当出现冲突的时候，我们比较堆顶元素与待选择元素的学习时长，选择时长更短的课程进行学习。

import java.util.Arrays;
import java.util.PriorityQueue;

public class Solution {
    public static int scheduleCourse(int[][] courses) {
        // 按课程截止时间升序排序
        Arrays.sort(courses, (a, b) -> a[1] - b[1]);
        // 大根堆，学习时长更长的在堆顶
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> b[0] - a[0]);
        // 记录总学习时长
        int total = 0;
        // 按截止时间从近到远遍历课程
        for (int[] course : courses) {
            // 如果总时长不会超过截止时间，那么，当前这门课程可以选择，直接入堆
            if (total + course[0] <= course[1]) {
                total += course[0];
                heap.offer(course);
            } else if (!heap.isEmpty() && heap.peek()[0] > course[0]) {
                // 出现冲突，优先选择学习时长更短的课程
                total = total - heap.poll()[0] + course[0];
                heap.offer(course);
            }
        }
        // 堆中有多少课程就是结果
        return heap.size();
    }
}
